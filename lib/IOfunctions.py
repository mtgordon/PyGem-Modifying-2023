from math import floor

import linecache
import numpy as np

import xml.etree.ElementTree as ET
import shutil

from lib.Scar_Generate import get_points_below, get_points_x_from_mid
from lib.workingWith3dDataSets import DataSet3d

'''
Function: openFile
'''


def openFile(file_name):
    """
    Opens a file and returns its content as a list of lines.

    Parameters:
        file_name (str): The name of the file to open.

    Returns:
        list: A list where each element is a stripped line from the file.

    Description:
        This function opens the file specified by 'file_name' and reads its content. Each line of the file is stored as
        an element in a list. The function then strips leading and trailing whitespaces from each line.

        The function returns the list of lines as the content of the file.

    Example:
        >>> content = openFile('input.txt')
        >>> print(content)
        ['Line 1', 'Line 2', 'Line 3']

    Note:
        - The function assumes that the file exists and can be successfully opened.
        - It is recommended to use this function to open text-based files.
    """
    with open(file_name) as f:
        content = f.readlines()
    content = [x.strip() for x in content]
    return content


'''
Function: extractNodesFromINP
'''


def extractNodesFromINP(file_name, part, nodes):
    """
    Extracts the coordinates of the specified nodes from a given part in an Abaqus input file.

    Parameters:
        file_name (str): The name of the .inp file.
        part (str): The name of the part from which nodes should be extracted.
        nodes (list): A list of node numbers to be extracted.

    Returns:
        list: A list of node coordinates.

    Description:
        This function reads the content of the Abaqus input file specified by 'file_name' and extracts the coordinates
        of the specified nodes from the given 'part'. The node coordinates are extracted from the 'TissueCoordinates'
        array generated by calling the 'extractPointsForPartFrom' function.

        The function iterates over the provided 'nodes' list and retrieves the coordinates for each node from the
        'TissueCoordinates' array. The extracted node coordinates are added to the 'NodeCoordinates' list.

        The function returns a list of node coordinates.

    Example:
        >>> file_name = "input.inp"
        >>> part = "MyPart"
        >>> nodes = [1, 3, 5]
        >>> node_coordinates = extractNodesFromINP(file_name, part, nodes)
        >>> print(node_coordinates)
        [[1.0, 2.0, 3.0], [4.0, 5.0, 6.0], [7.0, 8.0, 9.0]]
    """
    TissueCoordinates = np.array(extractPointsForPartFrom(file_name, part, get_connections=False))
    #    print(TissueCoordinates)
    NodeCoordinates = []
    for i in nodes:
        NodeCoordinates.append(TissueCoordinates[i - 1])
    return NodeCoordinates


'''
Function: extractPointsForPartFrom
'''


def extractPointsForPartFrom(file_name, part, get_connections=False):
    """
    Extracts the points for a specified part from an Abaqus input file. It can also optionally return the connections between the points.

    Parameters:
        file_name (str): The name of the .inp file.
        part (str): The name of the part from which points should be extracted.
        get_connections (bool, optional): If true, also returns the connections between points.

    Returns:
        list: A list of point coordinates, and optionally a dictionary of connections.

    Description:
        This function reads an Abaqus input file specified by 'file_name' and extracts the points belonging to the specified 'part'. The 'part' is identified using the '*Part, name=' keyword followed by the part name.

        The function iterates through the lines of the file and collects the point coordinates belonging to the 'part'. The coordinates are stored as a list of lists, where each inner list represents the [x, y, z] coordinates of a point.

        If the 'get_connections' parameter is set to True, the function also extracts the connections between points and returns them as a dictionary. The dictionary uses the node number as the key and the connected nodes as the value.

        The extracted data is returned as a list of point coordinates, and if requested, a dictionary of connections. If the 'part' is not found in the input file, an empty list is returned.

    Note:
        - This function assumes that the Abaqus input file follows a specific format with valid syntax. Unexpected or malformed file structures may lead to incorrect results or errors.

    Example usage:
        >>> extractPointsForPartFrom('input.inp', 'MyPart', get_connections=True)
    """
    # print(file_name)
    content = openFile(file_name)

    found = False
    line_index = 1
    part = "*Part, name=" + part
    line_vals = []
    # connection_vals = []
    conVal = {}
    started = False
    started_connections = False
    for line in content:
        if not found and part not in line:
            continue  # go to next line
        elif not found:
            found = True
        else:

            data = line.split(",")
            try:
                # if line contains the next expected node number
                if int(data[0]) == line_index:

                    # append data
                    started = True
                    if started_connections and get_connections:
                        # make a temp list contain the data in one line
                        temp = list(map(int, data[1:]))
                        # set the first item as a key and the after to be the value
                        conVal[temp[0]] = temp[1:]
                    else:

                        line_vals.append(data)

                    line_index += 1

                # if we have started parsing data and the next line is not our expected node number
                elif started:
                    # we have collected al the data
                    break
            # occurs at "*Node" after we have found part name
            except ValueError:
                if data[0] == "*Element" and get_connections:
                    started_connections = True
                    line_index = 1
                continue

    xyz_vals = []
    for data_point in line_vals:
        # the node values are strings and need to be converted to floats
        xyz_vals.append([float(data_point[1]), float(data_point[2]), float(data_point[3])])

    if get_connections:
        return xyz_vals, conVal
    else:
        return xyz_vals


'''
Function: extractPointsForPartFrom2
'''


def extractPointsForPartFrom2(file_name, part, get_connections=False):
    """
    Extracts the points for a specified part from a file and optionally retrieves the connections between nodes.

    Parameters:
        file_name (str): The name of the file to extract points from.
        part (str): The name of the part to extract points for.
        get_connections (bool, optional): Whether to also retrieve the connections between nodes. Default is False.

    Returns:
        tuple or list: If 'get_connections' is True, returns a tuple containing the following elements:
            - points (list): A list of lists, where each sublist represents the x, y, and z coordinates of a point.
            - connections (list): A list of lists, where each sublist represents the connections of a node.
        If 'get_connections' is False, returns a list of lists representing the x, y, and z coordinates of the points.

    Description:
        This function reads the content of the specified file and extracts the points belonging to the specified part.
        It searches for the part name preceded by "*Part, name=" to identify the start of the point data.
        The point data is expected to follow the format of node numbers and their corresponding x, y, and z coordinates.

        If 'get_connections' is True, the function also retrieves the connections between nodes. The connections are
        expected to follow the format of element numbers and their corresponding node numbers.

        The function returns the extracted points as a list of lists representing the x, y, and z coordinates.
        If 'get_connections' is True, it also returns the connections as a list of lists representing the connections of each node.

    Example:
        >>> file_name = "input.inp"
        >>> part = "MyPart"
        >>> points = extractPointsForPartFrom2(file_name, part)
        >>> print(points)
        [[1.0, 2.0, 3.0], [4.0, 5.0, 6.0], [7.0, 8.0, 9.0]]

        >>> file_name = "input.inp"
        >>> part = "MyPart"
        >>> points, connections = extractPointsForPartFrom2(file_name, part, get_connections=True)
        >>> print(points)
        [[1.0, 2.0, 3.0], [4.0, 5.0, 6.0], [7.0, 8.0, 9.0]]
        >>> print(connections)
        [[2, 3], [1, 3], [1, 2]]

    Note:
        - This function assumes that the input file follows a specific format with node numbers and coordinates.
        - The part name should match the actual part name in the input file.
        - If 'get_connections' is set to True, the connections are expected to follow a specific format with element numbers and node numbers.
    """
    content = openFile(file_name)
    found = False
    line_index = 1
    part = "*Part, name=" + part
    line_vals = []
    connection_vals = []
    started = False
    started_connections = False
    for line in content:
        if not found and part not in line:
            continue  # go to next line
        elif not found:
            found = True
        else:

            data = line.split(",")
            try:
                # if line contains the next expected node number
                if int(data[0]) == line_index:

                    # append data
                    started = True
                    if started_connections and get_connections:
                        temp = list(map(int, data[1:]))
                        connection_vals.append(temp)
                    else:
                        line_vals.append(data)

                    line_index += 1

                # if we have started parsing data and the next line is not our expected node number
                elif started:
                    # we have collected al the data
                    break
            # occurs at "*Node" after we have found part name
            except ValueError:
                if data[0] == "*Element" and get_connections:
                    started_connections = True
                    line_index = 1
                    continue
                else:
                    continue

    xyz_vals = []
    for data_point in line_vals:
        # the node values are strings and need to be converted to floats
        xyz_vals.append([float(data_point[1]), float(data_point[2]), float(data_point[3])])

    if get_connections:
        return xyz_vals, connection_vals
    else:
        return xyz_vals


'''
Function: write_new_inp_file
'''


def write_new_inp_file(file_name, part, new_file_name, data_set):
    """
    Writes a new Abaqus input file (.inp) with updated point data for a specified part.

    Parameters:
        file_name (str): The name of the original Abaqus input file.
        part (str): The name of the part where the point data will be updated.
        new_file_name (str): The name of the new Abaqus input file to be created.
        data_set (DataSet3d): An instance of the DataSet3d class containing the updated point data.

    Returns:
        None

    Description:
        This function reads the content of the original Abaqus input file specified by 'file_name' and searches for the specified 'part' to identify the point data section.
        It creates a new Abaqus input file specified by 'new_file_name' and writes the updated point data to it.

        The updated point data is provided through an instance of the DataSet3d class named 'data_set'. It contains the x, y, and z coordinates of the new points.

        The function writes the new point data in the same format as the original file, with each line representing a point and its coordinates. The new point data replaces the existing data in the specified part.

    Example:
        >>> file_name = "input.inp"
        >>> part = "MyPart"
        >>> new_file_name = "output.inp"
        >>> data_set = DataSet3d([1.0, 2.0, 3.0], [4.0, 5.0, 6.0], [7.0, 8.0, 9.0])
        >>> write_new_inp_file(file_name, part, new_file_name, data_set)

    Note:
        - This function assumes that the input file is a valid Abaqus input file.
        - The 'part' name should match the actual part name in the input file.
        - The 'data_set' should be an instance of the DataSet3d class containing the same number of points as the original part.
        - The new Abaqus input file will be created with the specified 'new_file_name' and will contain the updated point data for the specified part.
    """
    node_pad = 7  # how big of a space to leave for the data
    data_pad = 13  # this insures that of a number is 3 digits long it will be padded with spaces to the specified justifaction to maintian the given length

    content = openFile(file_name)
    new_file = open(new_file_name, 'w')
    write = False
    found = False
    part = "*Part, name=" + part
    index = 0
    max_index = data_set.number_of_points - 1
    for line in content:
        if write and max_index >= index:
            """
            The  node number is Justified right with a length of 7
            """
            line = (str(index + 1).rjust(node_pad) + ',' + str(data_set.xAxis[index]).rjust(data_pad) + ',' + str(
                data_set.yAxis[index]).rjust(data_pad) + ', ' + str(data_set.zAxis[index]).rjust(data_pad))
            new_file.write(line + "\n")
            index += 1
        else:
            new_file.write(line + "\n")

        if found and not write:
            write = True

        if part in line:
            found = True

    new_file.close()


'''
Function: write_part_to_inp_file
'''


def write_part_to_inp_file(file_name, part, data_set):
    """
    Writes the updated point data for a specified part to an Abaqus input file (.inp).

    Parameters:
        file_name (str): The name of the Abaqus input file.
        part (str): The name of the part where the point data will be updated.
        data_set (DataSet3d): An instance of the DataSet3d class containing the updated point data.

    Returns:
        None

    Description:
        This function reads the content of the Abaqus input file specified by 'file_name' and searches for the specified 'part' to identify the point data section.
        It updates the point data for the specified part with the coordinates provided in the 'data_set' instance.

        The function writes the updated point data to the same input file, overwriting the original data. The new point data is written in the same format as the original file, with each line representing a point and its coordinates.

    Example:
        >>> file_name = "input.inp"
        >>> part = "MyPart"
        >>> data_set = DataSet3d([1.0, 2.0, 3.0], [4.0, 5.0, 6.0], [7.0, 8.0, 9.0])
        >>> write_part_to_inp_file(file_name, part, data_set)

    Note:
        - This function assumes that the input file is a valid Abaqus input file.
        - The 'part' name should match the actual part name in the input file.
        - The 'data_set' should be an instance of the DataSet3d class containing the same number of points as the original part.
        - The function overwrites the original Abaqus input file with the updated point data for the specified part.
    """

    node_pad = 7  # how big of a space to leave for the data
    data_pad = 13  # this insures that of a number is 3 digits long it will be padded with spaces to the specified justifaction to maintian the given length
    #    print(file_name)
    content = openFile(file_name)
    f = open(file_name, 'w')
    write = False
    found = False
    part = "*Part, name=" + part
    index = 0
    max_index = data_set.number_of_points - 1
    for line in content:
        if write and max_index >= index:
            """
            The  node number is Justified right with a length of 7
            """
            line = (str(index + 1).rjust(node_pad) + ',' + str(data_set.xAxis[index]).rjust(data_pad) + ',' + str(
                data_set.yAxis[index]).rjust(data_pad) + ', ' + str(data_set.zAxis[index]).rjust(data_pad))
            f.write(line + "\n")
            index += 1
        else:
            f.write(line + "\n")

        if found and not write:
            write = True

        if part in line:
            found = True

    f.close()


'''
Function: get_dataset_from_file

Extracts points but puts it into DataSet3d class
'''


def get_dataset_from_file(file_name, part_name):
    """
    Extracts points from a part in an Abaqus input file and returns them as an instance of the DataSet3d class.

    Parameters:
        file_name (str): The name of the .inp file.
        part_name (str): The name of the part from which points should be extracted.

    Returns:
        DataSet3d: An instance of DataSet3d containing the extracted points.

    Description:
        This function reads an Abaqus input file specified by 'file_name' and extracts the points belonging to the specified 'part_name'.
        The 'part_name' is identified using the '*Part, name=' keyword followed by the part name.

        The function utilizes the 'extractPointsForPartFrom' function to extract the points for the specified part.
        The extracted points are then converted to a numpy array and stored in the 'np_points' variable.

        Finally, the function creates an instance of the DataSet3d class using the extracted x, y, and z coordinates from 'np_points'
        and returns it as the result.

    Example usage:
        >>> dataset = get_dataset_from_file('input.inp', 'MyPart')
    """
    #    print(file_name, part_name)
    np_points = np.array(extractPointsForPartFrom(file_name, part_name))
    #    print(np_points)
    return DataSet3d(list(np_points[:, 0]), list(np_points[:, 1]), list(np_points[:, 2]))


'''
Function: get_interconnections
'''


def get_interconnections(file_name, part_name):  # connections-between-material
    """
    Retrieves the interconnections between nodes in a specified part from an Abaqus input file.

    Parameters:
        file_name (str): The name of the Abaqus input file.
        part_name (str): The name of the part from which interconnections should be extracted.

    Returns:
        list: A list of lists, where each sublist contains the node numbers connected to the corresponding node.

    Description:
        This function reads the content of the Abaqus input file specified by 'file_name' and searches for the specified 'part_name' to identify the interconnections between nodes.
        It extracts the node interconnections from the input file by parsing the lines after the "*Part, name=" section until it encounters the next section or element.

        The function returns a list of lists, where each sublist represents a node and contains the node numbers connected to that node.

    Example:
        >>> file_name = "input.inp"
        >>> part_name = "MyPart"
        >>> interconnections = get_interconnections(file_name, part_name)
        >>> print(interconnections)
        [[2, 3, 4], [1, 3, 4], [1, 2, 4], [1, 2, 3]]

    Note:
        - This function assumes that the input file is a valid Abaqus input file.
        - The 'part_name' should match the actual part name in the input file.
        - The interconnections are based on the assumption that they follow the node numbering section and precede the next section or element in the input file.
    """
    connections = []
    number_of_nodes = len(extractPointsForPartFrom(file_name, part_name))

    # creates a list of empty nodes
    for i in range(0, number_of_nodes):
        connections.append([])

    findLine = "*Part, name=" + part_name

    with open(file_name, 'r') as f:
        while True:
            line = f.readline()
            if line.startswith(findLine):
                break
        while True:
            line = f.readline()
            if line.startswith("*Element"):
                break
        while True:
            if line.startswith("*Element"):  # we don't care
                line = f.readline()
            elif line.startswith("*"):  # done getting connections
                break
            else:
                strings = line.replace(" ", "").strip().split(",")
                nums = []
                for num in strings:
                    nums.append(int(num))

                connections = addToVals(connections, nums[1:])
                line = f.readline()

    return connections


'''
Function: addToVals
'''


def addToVals(connections, nums):
    """
    Adds connections between nodes to the existing list of connections.

    Parameters:
        connections (list): The existing list of connections.
        nums (list): A list of node numbers that should be connected.

    Returns:
        list: The updated list of connections.

    Description:
        This function takes an existing list of connections and adds additional connections between nodes based on the provided 'nums' list.
        The 'connections' list represents the connections between nodes, where each element at index 'i' corresponds to the connections of node 'i + 1'.
        The 'nums' list contains the node numbers that should be connected.

        If the length of 'nums' is less than 4, each node in 'nums' is connected to all other nodes in 'nums' that are not already connected to it.
        If the length of 'nums' is 4, a square pattern of connections is formed between the four nodes.
        If the length of 'nums' is not 2, 3, or 4, a RuntimeError is raised.

        The function modifies the 'connections' list in-place and returns the updated list.

    Note:
        - This function assumes that the node numbering starts from 1, so the node numbers in the 'connections' list and 'nums' list should be in the range of 1 to N, where N is the total number of nodes.

    Example usage:
        >>> connections = [[], [], []]
        >>> nums = [2, 3, 5]
        >>> updated_connections = addToVals(connections, nums)
    """

    if len(nums) < 4:
        for num in nums:
            # goto connection[num], add all unique in nums
            for neighbor in nums:
                if neighbor not in connections[num - 1] and neighbor != num:
                    connections[num - 1].append(neighbor)

    elif len(nums) == 4:
        for i, num in enumerate(nums):
            for j, neighbor in enumerate(nums):
                if neighbor not in connections[num - 1] and (
                        i + j) % 2 == 1:  # indices 0,1,2,3 and each is the corner of a square; do not want diagonal or self.
                    # all the ones we want to add are odd+even indices
                    # odd+odd or even+even only occur when adding diagonals or self
                    connections[num - 1].append(neighbor)

    else:
        raise (RuntimeError("Error retrieving connections; can only handle sets of 2, 3, or 4 values"))
    return connections


'''
Function: findLineNum

Returns the line number (not index) that a given string occurs in
'''


def findLineNum(file_location, string):
    """
    Finds the line number in a file where a specific string occurs.

    Parameters:
        file_location (str): The location of the file.
        string (str): The string to search for.

    Returns:
        int: The line number where the string occurs.

    Raises:
        EOFError: If the string is not found in the file.

    Description:
        This function opens the file specified by 'file_location' and iterates over each line, searching for the occurrence of the specified 'string'.
        If the string is found, the function returns the corresponding line number.
        If the string is not found, an EOFError is raised.

    Example:
        >>> file_location = "data.txt"
        >>> string = "Hello, World!"
        >>> line_number = findLineNum(file_location, string)
        >>> print(line_number)
        5

    Note:
        - The line numbers start from 1.
        - The function assumes that the file exists and is readable.
    """
    lineNum = 1
    f = open(file_location, 'r')
    for line in f:
        if string == line.strip():
            return lineNum
        lineNum += 1
    raise EOFError("String not found", file_location, string)


############### functions for reading csv file once it has been created with nodal coordinates
'''
Function: getFEAData
'''


def getFEAData(FileName, nodes):
    """
    Retrieves FEA data from a CSV file and extracts the coordinates of the specified number of nodes.

    Parameters:
        FileName (str): The name of the CSV file.
        nodes (int): The number of nodes to extract coordinates for.

    Returns:
        list: A list containing the extracted coordinates as separate arrays for x, y, and z axes.

    Description:
        This function reads the CSV file specified by 'FileName' using the numpy.genfromtxt() function, assuming that the data is comma-separated.
        It initializes empty arrays for x, y, and z coordinates with the size of 'nodes'.
        Then, it iterates over each node index and extracts the x, y, and z coordinates from the CSV data, assuming that the coordinates for each node are stored in consecutive rows with three values per row.
        The extracted coordinates are stored in the corresponding arrays.
        Finally, the function returns a list containing the arrays for x, y, and z coordinates.

    Example:
        >>> FileName = "data.csv"
        >>> nodes = 10
        >>> coordinates = getFEAData(FileName, nodes)
        >>> x_coords, y_coords, z_coords = coordinates
        >>> print(x_coords)
        [1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0]
        >>> print(y_coords)
        [1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0]
        >>> print(z_coords)
        [1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0]

    Note:
        - The CSV file should contain the coordinates of nodes in consecutive rows, with three values (x, y, z) per row.
        - The number of nodes specified should match the actual number of nodes in the CSV file.
    """
    csv = np.genfromtxt(FileName, delimiter=",")
    #    print(csv)
    #    [rows,columns] = csv.shape
    #    print(rows)
    #    print(columns)
    x = np.zeros(nodes)
    y = np.zeros(nodes)
    z = np.zeros(nodes)
    for i in range(0, nodes):
        x[i] = csv[i * 3]
        y[i] = csv[i * 3 + 1]
        z[i] = csv[i * 3 + 2]
    return [x, y, z]


'''
Function: getFEADataCoordinates
'''


def getFEADataCoordinates(FileName):
    """
    Retrieves FEA data coordinates from a CSV file and returns separate arrays for x, y, and z axes.

    Parameters:
        FileName (str): The name of the CSV file.

    Returns:
        list: A list containing the extracted coordinates as separate arrays for x, y, and z axes.

    Description:
        This function reads the CSV file specified by 'FileName' using the numpy.genfromtxt() function, assuming that the data is comma-separated.
        It checks if there are multiple rows of data and selects the last row for extraction. If there is only one row, it uses that row.
        It calculates the number of nodes based on the length of the data row divided by 3.
        It initializes empty arrays for x, y, and z coordinates with the size of 'nodes'.
        Then, it iterates over each node index and extracts the x, y, and z coordinates from the data row, assuming that the coordinates for each node are stored in consecutive positions with three values per node.
        The extracted coordinates are stored in the corresponding arrays.
        Finally, the function returns a list containing the arrays for x, y, and z coordinates.

    Example:
        >>> FileName = "data.csv"
        >>> coordinates = getFEADataCoordinates(FileName)
        >>> x_coords, y_coords, z_coords = coordinates
        >>> print(x_coords)
        [1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0]
        >>> print(y_coords)
        [1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0]
        >>> print(z_coords)
        [1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0]

    Note:
        - The CSV file should contain the coordinates of nodes in consecutive positions, with three values (x, y, z) per node.
        - The function assumes that the CSV file exists and is formatted correctly with the expected number of coordinates.
    """

    csv = np.genfromtxt(FileName, delimiter=",")

    # If there are multiple rows, get the last one
    try:
        data = csv[-1, :]
    except IndexError:
        data = csv

    nodes = floor((len(data) / 3))
    x = np.zeros(nodes)
    y = np.zeros(nodes)
    z = np.zeros(nodes)
    for i in range(0, nodes):
        x[i] = data[i * 3]
        y[i] = data[i * 3 + 1]
        z[i] = data[i * 3 + 2]
    return [x, y, z]


'''
Function: getInitialPositions
'''


def getInitialPositions(FileName, nodes):
    """
    Retrieves the initial positions of nodes from a CSV file and returns separate arrays for x, y, and z axes.

    Parameters:
        FileName (str): The name of the CSV file.
        nodes (int): The number of nodes in the CSV file.

    Returns:
        list: A list containing the extracted initial positions as separate arrays for x, y, and z axes.

    Description:
        This function reads the CSV file specified by 'FileName' using the numpy.genfromtxt() function, assuming that the data is comma-separated.
        It extracts the second column as the x-coordinate array, the third column as the y-coordinate array, and the fourth column as the z-coordinate array.
        The function assumes that the CSV file has rows with node indices and corresponding x, y, and z coordinates.
        The 'nodes' parameter specifies the number of nodes expected in the CSV file, which determines the size of the coordinate arrays.
        The extracted coordinate arrays are returned as a list containing separate arrays for x, y, and z axes.

    Example:
        >>> FileName = "data.csv"
        >>> nodes = 10
        >>> positions = getInitialPositions(FileName, nodes)
        >>> x_coords, y_coords, z_coords = positions
        >>> print(x_coords)
        [1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0]
        >>> print(y_coords)
        [1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0]
        >>> print(z_coords)
        [1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0]

    Note:
        - The CSV file should contain rows with node indices and corresponding x, y, and z coordinates.
        - The 'nodes' parameter should be accurate to match the number of nodes in the CSV file.
        - The function assumes that the CSV file exists and is formatted correctly with the expected number of nodes and coordinates.
    """

    csv = np.genfromtxt(FileName, delimiter=",")
    x = np.array(csv[:, 1])
    y = np.array(csv[:, 2])
    z = np.array(csv[:, 3])
    return [x, y, z]


## ************************************************************************************************* ##
## ****************************Below is New Functions created by Yutian Yang************************ ##
# Author: Yutian Yang
# Created: 5/15/2023
# Description: This is a file of all the IO functions that edited fot .feb file
# from what was written for the .inp file before
# Version: 1.0
# Email: yyt542985333@gmail.com




'''
Function: write_Nset_to_inp_file
'''


def write_Nset_to_inp_file(file_name, part, Nset_num, section, material, Nset_list):
    """
    Write a new Nset (node set) to an input file.

    Parameters:
        file_name (str): The name of the input file to write to.
        part (str): The name of the part to modify.
        Nset_num (int): The number of the new Nset.
        section (str): The name of the section associated with the Nset.
        material (str): The material associated with the section.
        Nset_list (list): The list of node numbers to be included in the Nset.

    Description:
        This function modifies an input file by adding a new Nset (node set) to the specified part. The Nset is created
        with the given number (Nset_num) and includes the list of node numbers (Nset_list). Additionally, the function
        adds a section to the input file that associates the Nset with a specified section name (section) and material
        (material).

        The function reads the content of the original input file, finds the part to be modified, and inserts the new Nset
        and section at the appropriate locations. The modified content is then written back to the input file.

    Example:
        >>> file_name = "input_file.inp"
        >>> part = "Part1"
        >>> Nset_num = 1
        >>> section = "Section1"
        >>> material = "Material1"
        >>> Nset_list = [1, 2, 3, 4, 5]
        >>> write_Nset_to_inp_file(file_name, part, Nset_num, section, material, Nset_list)

    Notes:
        - The function assumes that the input file follows the INP format used by Abaqus software.
        - The part name (part) should match the exact name used in the input file.
        - The Nset number (Nset_num) should be unique and not conflict with existing Nsets.
        - The section name (section) and material (material) should match the names defined in the input file.
        - The Nset_list should contain valid node numbers corresponding to the nodes in the specified part.
    """

    node_pad = 3  # how big of a space to leave for the data
    line_pad = 16  # how many number in each line

    # print(file_name)

    content = openFile(file_name)

    part = "*Part, name=" + part
    index = 0
    max_index = len(Nset_list) - 1

    with open(file_name, 'w') as f:
        write = False
        found = False
        found_Nset = False
        found_section = False
        section_written = False

        for line in content:
            if part in line:
                found = True

            if found and ("*Nset, nset=" in line):
                found_Nset = True

            if found_Nset and ("** Section:" in line):
                found_section = True

            if found_Nset and not write:
                Nset = "*Nset, nset=_PickedSet" + str(Nset_num) + ", internal, generate" + "\n"
                f.write(Nset)
                write = True

            if write and max_index >= index:
                """
                The  node number is Justified right with a length of 4
                """
                for i in range(0, len(Nset_list), line_pad):
                    Nset_line = ', '.join(str(number).rjust(node_pad) for number in Nset_list[i:i + line_pad])
                    f.write(Nset_line + "\n")
                    index += line_pad
                print("Successfully insert new Nset", Nset_num)

            elif found_section and not section_written:
                section_line = "** Section: " + section + "\n" + "*Shell Section, elset=_PickedSet" + str(
                    Nset_num) + ", material=" + str(material) + "\n" + "2., 5"
                f.write(section_line + "\n")
                section_written = True
                print("Successfully insert new Section", section)

            f.write(line + "\n")

    '''
    Function: write_new_part_to_inp_file
    '''


def get_dis_Nset_points_list(file_name, part_name, section_name):
    """
    Retrieves a list of node indices from an Abaqus input file (.inp) belonging to a specified dissection Nset.

    Parameters:
        file_name (str): The path to the Abaqus input file (.inp).
        part_name (str): The name of the part where the dissection Nset is located.
        section_name (str): The name of the dissection section.

    Returns:
        list or None: A list of node indices belonging to the dissection Nset, or None if the section is not found.

    Description: This function reads the content of the Abaqus input file specified by 'file_name' and searches for 
    the specified 'part_name' and 'section_name' to identify the dissection Nset. The Nset is identified by the 
    '*Nset, nset=' keyword followed by the Nset number.

        The function retrieves the node indices belonging to the dissection Nset by parsing the lines after the Nset definition until it encounters the next section or Nset. The node indices are returned as a list.

        If the specified 'section_name' is not found within the 'part_name', the function prints an error message and 
        returns None.

    Example:
        >>> node_indices = get_dis_Nset_points_list('input.inp', 'MyPart', 'MySection')

    Note: - This function assumes that the input file is a valid Abaqus .inp file. - The 'part_name' and 
    'section_name' should match the actual part and section names in the input file. - Ensure that the dissection 
    Nset is correctly defined using the '*Nset, nset=' keyword. - The function retrieves node indices based on the 
    assumption that they follow the Nset definition and precede the next section or Nset in the input file.
    """
    content = openFile(file_name)
    part = "*Part, name=" + str(part_name)
    dis_section = "** Section: " + str(section_name) + "_dis"

    found_part = False
    found_section = False
    line_number = 0
    set_numbers = {}

    for line in content:
        line_number += 1
        if part in line:
            found_part = True
        if found_part and "*Nset, nset=_PickedSet" in line:
            set_number = line.split("_PickedSet")[1].split(",")[0].strip()
            set_numbers[set_number] = line_number

        if found_part and dis_section in line:
            found_section = True
            break

    if not found_section:
        print("No " + str(section_name) + "_dis found!")
        return None

    line_number += 1
    line = linecache.getline(file_name, line_number)
    exclude_set_number = line.split("_PickedSet")[1].split(",")[0].strip()
    exclude_points_list = []

    line_number = set_numbers[exclude_set_number]
    line = linecache.getline(file_name, line_number + 1)

    while "*Elset, elset=" not in line and "*Nset, nset=" not in line:
        numbers = line.strip().split(",")
        numbers = [int(num.strip()) for num in numbers]
        exclude_points_list.extend(numbers)
        line_number += 1
        line = linecache.getline(file_name, line_number)

    return exclude_points_list


def exclude_points_in_list(original_list, exclude_list):
    """
    Excludes numbers from an original list based on an exclude list and returns a new list.

    Parameters:
        original_list (list): The original list of numbers.
        exclude_list (list): The list of numbers to be excluded.

    Returns:
        list: A new list that contains numbers from the original list excluding those present in the exclude list.

    Example:
        >>> original_list = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
        >>> exclude_list = [3, 5, 7]
        >>> result_list = exclude_points_in_list(original_list, exclude_list)
        >>> print(result_list)
        [1, 2, 4, 6, 8, 9, 10]
    """
    return [num for num in original_list if num not in exclude_list]


def write_points_below_excluded_to_inp(file_name, part_name, threshold_percent_from_bot, Nset_num, section_name,
                                       material):
    """
    Write the points below a certain threshold percentage from the bottom to an INP file.

    Parameters:
        file_name (str): The name of the INP file to write the points to.
        part_name (str): The name of the part containing the points.
        threshold_percent_from_bot (float): The threshold percentage from the bottom to exclude points.
        Nset_num (int): The Nset number to assign to the excluded points.
        section_name (str): The section name to assign to the excluded points.
        material (str): The material to assign to the section.

    Returns:
        None

    Description:
        This function writes the points below a specified threshold percentage from the bottom of a part to an INP file.
        It first gets the points below the threshold using the `get_points_below()` function. Then, it retrieves the
        excluded points from the INP file using the `get_dis_Nset_points_list()` function. It further filters out any
        points that are already excluded. Finally, it calls the `write_Nset_to_inp_file()` function to write the filtered
        points to the INP file.

    Example:
        >>> file_name = "example.inp"
        >>> part_name = "Part1"
        >>> threshold_percent_from_bot = 20.0
        >>> Nset_num = 1
        >>> section_name = "Section1"
        >>> material = "Material1"
        >>> write_points_below_excluded_to_inp(file_name, part_name, threshold_percent_from_bot, Nset_num, section_name, material)

    Notes:
        - The INP file must exist and be accessible for writing.
        - The part name (part_name) should match the exact name used in the INP file.
        - The threshold_percent_from_bot value represents the percentage of points to exclude from the bottom of the part.
        - The Nset_num value is used to assign a unique Nset number to the excluded points.
        - The section_name is the name to assign to the excluded points' section.
        - The material is the material to assign to the section.
        - The function assumes that the `get_points_below()`, `get_dis_Nset_points_list()`, and `write_Nset_to_inp_file()`
          functions are defined elsewhere in the codebase.
    """

    original_list = get_points_below(file_name, part_name, threshold_percent_from_bot)[0]
    exclude_list = get_dis_Nset_points_list(file_name, part_name, section_name)
    excluded_list = exclude_points_in_list(original_list, exclude_list)
    write_Nset_to_inp_file(file_name, part_name, Nset_num, section_name, material, excluded_list)


def write_points_x_from_mid_excluded_to_inp(file_name, part_name, mid_x, threshold_x_from_mid, Nset_num, section_name,
                                            material):
    """
    Write excluded points (based on x-coordinate from the mid-point) to an input file as a new Nset.

    Parameters:
        file_name (str): The name of the input file to write to.
        part_name (str): The name of the part containing the points.
        mid_x (float): The x-coordinate of the mid-point.
        threshold_x_from_mid (float): The threshold distance from the mid-point of x for exclusion.
        Nset_num (int): The number of the new Nset.
        section_name (str): The name of the section associated with the Nset.
        material (str): The material associated with the section.

    Description:
        This function identifies points in the specified part that have x-coordinates within a threshold distance from
        the mid-point of x. It excludes those points from the original list of points and writes the remaining points as a new
        Nset (node set) to the input file. The new Nset is associated with the specified section and material.

        The function utilizes other utility functions to extract the original list of points, exclude points based on
        section membership, and write the new Nset to the input file.

    Example:
        >>> file_name = "input_file.inp"
        >>> part_name = "Part1"
        >>> mid_x = 5.0
        >>> threshold_x_from_mid = 1.0
        >>> Nset_num = 1
        >>> section_name = "Section1"
        >>> material = "Material1"
        >>> write_points_x_from_mid_excluded_to_inp(file_name, part_name, mid_x, threshold_x_from_mid, Nset_num, section_name, material)

    Notes:
        - The function assumes that the input file follows the INP format used by Abaqus software.
        - The part name (part_name) should match the exact name used in the input file.
        - The x-coordinate of the mid-point (mid_x) should be within the range of x-coordinates in the specified part.
        - The threshold distance (threshold_x_from_mid) should be a positive value.
        - The Nset number (Nset_num) should be unique and not conflict with existing Nsets.
        - The section name (section_name) and material (material) should match the names defined in the input file.
    """

    original_list = get_points_x_from_mid(file_name, part_name, mid_x, threshold_x_from_mid)[0]
    exclude_list = get_dis_Nset_points_list(file_name, part_name, section_name)
    excluded_list = exclude_points_in_list(original_list, exclude_list)
    write_Nset_to_inp_file(file_name, part_name, Nset_num, section_name, material, excluded_list)


def write_new_part_to_inp_file(file_name, part, element_type, points_list, element_list):
    """
    Writes a new part to an existing .inp file (Abaqus input file).

    Parameters:
        file_name (str): The path to the existing .inp file.
        part (str): The name of the new part.
        element_type (str): The type of the elements in the new part.
        points_list (list of 3 floats): A list of the nodes' coordinates.
            Each node is represented as a list of three coordinates [x, y, z].
        element_list (list of ints): A list of the element definitions.
            Each element is defined by three node indices (assuming triangular elements).

    Returns:
        None

    Description:
        This function reads the content of the existing .inp file and writes the new part information before the
        first occurrence of "*Part, name=". The new part information includes the nodes (coordinates) and elements
        (node indices). Each line in the file is padded to ensure proper alignment.

    Note:
        - If the file does not exist or cannot be opened due to insufficient permissions, an error message is printed, and the function returns immediately without making any changes.

    Example:
        >>> write_new_part_to_inp_file('existing_file.inp', 'NewPart', 'C3D4', [[0.0, 0.0, 0.0], [1.0, 0.0, 0.0]], [1, 2, 3])
    """
    element_pad = 4
    node_pad = 7  # how big of a space to leave for the data
    data_pad = 13  # this insures that of a number is 3 digits long it will be padded with spaces to the specified justifaction to maintian the given length
    #    print(file_name)

    content = openFile(file_name)
    with open(file_name, 'w') as f:
        found = False
        first_part = "*Part, name="

        for line in content:
            if first_part in line:
                found = True

            if found:
                part_line = "*Part, name=" + part
                f.write(part_line + "\n")
                f.write("*Node\n")
                for i in range(len(points_list)):
                    coordinates_line = (
                            str(i + 1).rjust(node_pad) + ', '
                            + str(points_list[i][0]).rjust(data_pad) + ', '
                            + str(points_list[i][1]).rjust(data_pad) + ', '
                            + str(points_list[i][2]).rjust(data_pad))
                    f.write(coordinates_line + "\n")
                print("Successfully insert the new part with the coordinates!")

                element = "*Element, type=" + str(element_type)
                f.write(element + "\n")

                for i in range(0, len(element_list), 2):
                    element_line = str(i // 3 + 1)  # add line number
                    if i < len(element_list):
                        element_line += ', ' + str(element_list[i]).rjust(element_pad)
                    if i + 1 < len(element_list):
                        element_line += ', ' + str(element_list[i + 1]).rjust(element_pad)
                    f.write(element_line + "\n")

                print("Successfully insert the new Element")

                end = "*End Part\n" + "**"
                f.write(end + "\n")
                found = False
            f.write(line + "\n")

    print("Successfully insert!")


# *************************************************************************************************************************
# def getBnodes(file_location,
#               BoundaryTissue):  # look for *Boundary and grab the next line after dropping the _ and only grabbing PickedSET### storing them in an array
#     BNodes = []
#     boundarySets = []
#     with open(file_location, 'r') as file:
#         line = "h"
#         while "** BOUNDARY CONDITIONS" not in line:
#             line = next(file)
#         while "** INTERACTIONS" not in line:
#             if "*Boundary" in line:
#                 boundarySets.append(next(file).split(",")[0])
#             line = next(file)
# 
#     with open(file_location, 'r') as file:  # items are above *Boundary lines, must be reopened
#         line = "line"
#         while True:
#             if isBoundaryLine(boundarySets, line):
#                 material = getName(line)
#                 if BoundaryTissue in material:
# 
#                     if "generate" in line:  # then it is parameters for an instruction
#                         instructions = getNodes(file, line)
#                         start = instructions[0]
#                         end = instructions[1]
#                         increment = instructions[2]
#                         nodes = np.arange(start, end + 1, increment).tolist()
#                         BNodes = BNodes + nodes
# 
#                     else:  # it's just a list of nodes
#                         newNodes = getNodes(file, line)
#                         for n in newNodes:
#                             if n not in BNodes:
#                                 BNodes.append(n)
#                 else:
#                     del line
#                 try:
#                     line = next(file)
#                 except StopIteration:
#                     break
#             else:
#                 try:
#                     line = next(file)
#                 except StopIteration:
#                     break
#         # BNodes.sort()
#     return BNodes
# 
# 
# def isBoundaryLine(boundarySets, line):
#     if "*Nset" in line:
#         line = line.split(", ")
#         name = line[1].split("=")[1]  # selects _PickedSet5 from nset=_PickedSet5
#         if name in boundarySets:
#             return True
#     return False
# 
# 
# def getNodes(file, line):
#     numberLines = []  # lines containing lists of numbers in the INP file
#     line = next(file)
#     while "*" not in line:
#         numberLines.append(line)
#         line = next(file)
# 
#     nodeIDs = []
#     for line in numberLines:
#         parseNumsFromCSV(nodeIDs, line)
#     return nodeIDs
# 
# 
# def getName(line):
#     line = line.split(", ")
#     name = line[3].split("=")[1].strip()  # selects _PickedSet5 from nset=_PickedSet5
#     return name
# 
# 
# def parseNumsFromCSV(nodeIDs, line):
#     line.replace(" ", "")  # delete spaces
#     numList = line.split(",")
#     for x in numList:
#         nodeIDs.append(int(x))  # int(x) converts it from string to integer


# Below are functions for feb files.

def extract_Nodes_from_feb(file_name, node_name, nodes_list):
    """
    Extracts the coordinates of the specified nodes from a given part in an Abaqus input file.

    Parameters:
        file_name (str): The name of the .inp file.
        node_name (str): The name of the node from which nodes should be extracted.
        nodes_list (list): A list of node numbers to be extracted.

    Returns:
        list: A list of node coordinates.

    Description:
        This function reads the content of the Abaqus input file specified by 'file_name' and extracts the coordinates
        of the specified nodes from the given 'part'. The node coordinates are extracted from the 'TissueCoordinates'
        array generated by calling the 'extractPointsForPartFrom' function.

        The function iterates over the provided 'nodes' list and retrieves the coordinates for each node from the
        'TissueCoordinates' array. The extracted node coordinates are added to the 'NodeCoordinates' list.

        The function returns a list of node coordinates.

    Example:
        >>> file_name = "input.inp"
        >>> part = "MyPart"
        >>> nodes = [1, 3, 5]
        >>> node_coordinates = extract_Nodes_from_feb(file_name, part, nodes)
        >>> print(node_coordinates)
        [[1.0, 2.0, 3.0], [4.0, 5.0, 6.0], [7.0, 8.0, 9.0]]
    """

    all_coordinates = extract_coordinates_list_from_feb(file_name, node_name)
    extract_coordinates = []
    for i in nodes_list:
        extract_coordinates.append(all_coordinates[i - 1])
    return extract_coordinates


def extract_coordinates_list_from_feb(file_name, node_name, get_connections=False):
    """
    Extracts the coordinates of nodes from an FEB file and returns them as a list.

    Parameters:
    - file_name (str): The name of the FEB file to extract coordinates from.
    - node_name (str): The name of the node element in the FEB file.
    - get_connections (bool, optional): Whether to also extract the connections between nodes. Default is False.

    Returns:
    - points_list (list): A list containing the coordinates of nodes as tuples. [(x, y, z), (x, y, z)]

    Description:
    This function parses the XML file specified by 'file_name' and searches for the 'Nodes' element with the given
    'node_name'. If found, it iterates over each 'node' element within the 'Nodes' element and extracts the
    coordinates.

    The extracted coordinates are converted to floating-point numbers and stored as tuples in the 'points_list'.
    Each tuple represents the 3D coordinates of a node.

    If the 'get_connections' parameter is set to True, the function can also extract the connections between nodes,
    but this functionality is not implemented in the provided code.

    If no 'Nodes' element with the specified 'node_name' is found, an appropriate error message is printed, and
    an empty list is returned.

    Example usage:
    >>> extract_coordinates_list_from_feb('input.feb', 'MyNodes', get_connections=True)
    """

    tree = ET.parse(file_name)
    root = tree.getroot()

    points_list = []  # an empty list
    connection_dic = {}  # an empty dictionary

    # Convert the XML tree into a list
    xml_elements = list(root.iter())

    # Find the 'Nodes' element with the target_name attribute
    for i, element in enumerate(xml_elements):
        if element.tag == "Nodes" and element.attrib.get('name') == node_name:
            for node in element.iter('node'):
                points_list.append(tuple(float(coordinate) for coordinate in node.text.split(',')))

            # If get_connections is True, also extract the 'elem' data from the next 'Elements' section
            if get_connections:
                for next_element in xml_elements[i + 1:]:
                    if next_element.tag == "Elements":
                        for elem in next_element.iter('elem'):
                            temp_list = list(map(int, elem.text.split(',')))
                            connection_dic[temp_list[0]] = temp_list[1:]
                        break
            break

    if not points_list:
        print(f"No 'Nodes' element with the name '{node_name}' found.")

    if get_connections:
        return points_list, connection_dic
    else:
        return points_list


def extract_coordinates_list_from_feb2(file_name, node_name, get_connections=False):
    """
    Extracts the coordinates of nodes from an FEB file and returns them as a list. Optionally, it can also extract the connections between nodes.

    Parameters:
        file_name (str): The name of the FEB file to extract coordinates from.
        node_name (str): The name of the node element in the FEB file.
        get_connections (bool, optional): Whether to also extract the connections between nodes. Default is False.

    Returns:
        list: A tuple containing the coordinates list and connection list (if get_connections is True),
        or just the coordinates list (if get_connections is False).

    Description:
        This function parses the XML file specified by 'file_name' and searches for the 'Nodes' element with the given 'node_name'. If found, it extracts the coordinates of each 'node' element within the 'Nodes' element and stores them in the 'points_list'.

        If the 'get_connections' parameter is set to True, the function can also extract the connections between nodes by searching for the 'Elements' section after the 'Nodes' section. The connections are stored in the 'connection_list'.

        If no 'Nodes' element with the specified 'node_name' is found, an appropriate error message is printed, and an empty list is returned.

    Example usage:
        >>> extract_coordinates_list_from_feb2('input.feb', 'MyNodes', get_connections=True)
    """
    tree = ET.parse(file_name)
    root = tree.getroot()

    points_list = []  # an empty list
    connection_list = []

    # Convert the XML tree into a list
    xml_elements = list(root.iter())

    # Find the 'Nodes' element with the target_name attribute
    for i, element in enumerate(xml_elements):
        if element.tag == "Nodes" and element.attrib.get('name') == node_name:
            for node in element.iter('node'):
                points_list.append(tuple(float(coordinate) for coordinate in node.text.split(',')))

            # If get_connections is True, also extract the 'elem' data from the next 'Elements' section
            if get_connections:
                for next_element in xml_elements[i + 1:]:
                    if next_element.tag == "Elements":
                        for elem in next_element.iter('elem'):
                            temp_list = list(map(int, elem.text.split(',')))
                            connection_list.append(temp_list)
                        break
            break

    if not points_list:
        print(f"No 'Nodes' element with the name '{node_name}' found.")

    if get_connections:
        return points_list, connection_list
    else:
        return points_list


def extract_node_id_list_from_feb(file_name, node_name):
    """
    Extracts the IDs of nodes from an FEB file and returns them as a list.

    Parameters:
        file_name (str): The name of the FEB file to extract node IDs from.
        node_name (str): The name of the node element in the FEB file.

    Returns:
        list: A list containing the IDs of nodes.

    Description:
        This function parses the XML file specified by 'file_name' and searches for the 'Nodes' element with the given 'node_name'. If found, it extracts the 'id' attribute of each 'node' element within the 'Nodes' element and stores them in the 'node_id_list'.

        If the 'get_connections' parameter is set to True, the function can also extract the connections between nodes, but this functionality is not implemented in the provided code.

        If no 'Nodes' element with the specified 'node_name' is found, an appropriate error message is printed, and an empty list is returned.

    Example usage:
        >>> extract_node_id_list_from_feb('input.feb', 'MyNodes', get_connections=True)
    """

    tree = ET.parse(file_name)
    root = tree.getroot()

    node_id_list = []  # an empty list

    # Find the 'Nodes' element with the target_name attribute
    nodes_element = root.find(f".//Nodes[@name='{node_name}']")

    # Check if the 'Nodes' element is found
    if nodes_element is not None:
        # Iterate over each 'node' element in the found 'Nodes' element
        # for node in nodes_element.iter('node'):
        #     node_id_list.append(tuple(float(coordinate) for coordinate in node.text.split(',')))

        node_id_list = [node.attrib['id'] for node in nodes_element.findall('node')]
    else:
        print(f"No 'Nodes' element with the name '{node_name}' found.")
    return node_id_list


def extract_coordinates_dic_from_feb(file_name, node_name):
    """
    Extracts the coordinates of nodes from an FEB file and returns them as a dictionary.

    Parameters:
    - file_name (str): The name of the FEB file to extract coordinates from.
    - node_name (str): The name of the node element in the FEB file.

    Returns:
    - nodes_dictionary (dict): A dictionary containing node IDs as keys and coordinates as values.

    Description:
    This function parses the XML file specified by 'file_name' and searches for the 'Nodes' element with the given
    'node_name'. If found, it iterates over each 'node' element within the 'Nodes' element, extracts the ID and
    coordinates of the node, and stores them in the 'nodes_dictionary' dictionary.

    The ID of each node is converted to an integer, and the coordinates are stored as a list of floats.

    If the 'get_connections' parameter is set to True, the function can also extract the connections between nodes,
    but this functionality is not implemented in the provided code.

    If no 'Nodes' element with the specified 'node_name' is found, an appropriate error message is printed, and
    an empty dictionary is returned.

    Example usage:
    >>> extract_coordinates_dic_from_feb('input.feb', 'MyNodes', get_connections=True)
    """
    tree = ET.parse(file_name)
    root = tree.getroot()

    nodes_dictionary = {}  # an empty dictionary

    # Find the 'Nodes' element with the target_name attribute
    nodes_element = root.find(f".//Nodes[@name='{node_name}']")

    # Check if the 'Nodes' element is found
    if nodes_element is not None:
        # Iterate over each 'node' element in the found 'Nodes' element
        for node in nodes_element.iter('node'):
            node_id = int(node.attrib['id'])
            coordinates = [float(coordinate) for coordinate in node.text.split(',')]  # list containing coordinates
            nodes_dictionary[node_id] = coordinates  # add the id as a key, the coordinates as value

    else:
        print(f"No 'Nodes' element with the name '{node_name}' found.")
    return nodes_dictionary


# TODO: get Dataset3D!!!!
def replace_node_in_new_feb_file(file_name, node_name, new_file_name, coordinates_list):
    """
    Replaces a node in an FEB file with the specified coordinates and saves the changes to a new FEB file.

    Parameters:
        file_name (str): The name of the original FEB file.
        node_name (str): The name of the node element to replace.
        new_file_name (str): The name of the new FEB file to save the changes.
        coordinates_list (list): A list of coordinates [x, y, z] for the new node.

    Returns:
        None

    Description:
        This function reads an existing FEB file specified by 'file_name' and finds the 'Mesh' element. It then creates
        a new FEB file specified by 'new_file_name' and replaces the existing 'Nodes' element with the specified
        'node_name' with a new 'Nodes' element that contains the provided coordinates. The 'Nodes' element to be
        replaced is identified by its 'name' attribute.

        The new 'Nodes' element is created with the provided 'node_name', and 'node' elements are added for each set
        of coordinates in the 'coordinates_list'. The 'id' attribute of each 'node' element is assigned sequentially
        starting from 1.

        Finally, the modified XML tree is written to the new FEB file, preserving the original FEB file.

    Notes:
        - If the 'Mesh' element or the 'Nodes' element with the specified 'node_name' is not found in the original FEB file,
          appropriate error messages are printed.
        - The original FEB file specified by 'file_name' remains unchanged. The changes are saved to the new FEB file
          specified by 'new_file_name'.
        - It is recommended to specify a different 'new_file_name' to avoid overwriting the original FEB file.

    Example:
        >>> replace_node_in_new_feb_file('input.feb', 'Nodes name', 'new_input.feb', [[1.0, 2.0, 3.0], [4.0, 5.0, 6.0], [7.0, 8.0, 9.0]])
    """
    #  create a copy of the original file
    shutil.copyfile(file_name, new_file_name)

    # Read the copied FEBio file
    tree = ET.parse(new_file_name)
    root = tree.getroot()

    # Find the 'Mesh' element
    mesh_element = root.find('Mesh')

    if mesh_element is not None:
        # Find the index of the 'Nodes' element with the specified 'name' attribute
        index = -1
        for i, nodes_element in enumerate(mesh_element):
            if nodes_element.tag == 'Nodes' and nodes_element.get('name') == node_name:
                index = i
                break

        # If the 'Nodes' element with the specified 'name' attribute is found, remove it
        if index != -1:
            mesh_element.remove(mesh_element[index])

            # Create a new 'Nodes' element and set the 'name' attribute
            new_nodes_element = ET.Element('Nodes')
            new_nodes_element.set('name', node_name)
            new_nodes_element.tail = "\n\t\t"
            new_nodes_element.text = "\n\t\t\t"

            # Iterate through the points in the coordinates_list and add them as 'node' elements
            for i, coordinates in enumerate(coordinates_list):
                node_element = ET.SubElement(new_nodes_element, 'node')
                node_element.set('id', str(i + 1))
                coordinates_text = f"{coordinates[0]}, {coordinates[1]}, {coordinates[2]}"
                node_element.text = coordinates_text
                node_element.tail = "\n\t\t\t"

            new_nodes_element[-1].tail = "\n\t\t"
            mesh_element.insert(index, new_nodes_element)

            # Write the updated XML tree to the new file
            tree.write(new_file_name, encoding='utf-8', xml_declaration=True)
        else:
            print(f"No 'Nodes' element with the name '{node_name}' found.")
    else:
        print("No 'Mesh' element found.")


# Append new one at the end.
# def write_node_to_feb_file(file_name, node_name, points_list):
#     # Read the existing FEBio file
#     tree = ET.parse(file_name)
#     root = tree.getroot()
#
#     # Create a new 'Nodes' element and set the 'name' attribute
#     nodes_element = ET.SubElement(root, 'Nodes')
#     nodes_element.set('name', node_name)
#
#     # Iterate through the points in the coordinates_list and add them as 'node' elements
#     for i, coordinates in enumerate(points_list):
#         node_element = ET.SubElement(nodes_element, 'node')
#         node_element.set('id', str(i + 1))
#         # The f denotes that it's an f-string. The expressions inside the curly
#         # braces are evaluated at runtime and then formatted using the format
#         # string syntax. In this case, coordinates[0], coordinates[1], and
#         # coordinates[2] will be evaluated and inserted into the resulting string.
#         coordinates_text = f"{coordinates[0]}, {coordinates[1]}, {coordinates[2]}"
#         node_element.text = coordinates_text
#
#     # Write the updated XML tree back to the file
#     tree.write(file_name, encoding='utf-8', xml_declaration=True)

# ###############################################################


# TODO: get Dataset3D!!!! Not coordinates list!
def replace_node_in_feb_file(file_name, node_name, coordinates_list):
    """
    Replaces the coordinates of a specific 'Nodes' element in an FEBio file with new coordinates.

    Parameters:
        file_name (str): The name of the FEBio file.
        node_name (str): The name of the 'Nodes' element to replace.
        coordinates_list (list): A list of coordinate tuples [(x1, y1, z1), (x2, y2, z2), ...] for the new coordinates.

    Returns:
        None

    Description:
        This function reads the FEBio file specified by 'file_name' and finds the 'Mesh' element.
        It searches for the 'Nodes' element with the specified 'name' attribute and removes it if found.
        Then, a new 'Nodes' element is created with the same 'name' attribute, and 'node' elements are added with the new coordinates.
        The updated XML tree is then written back to the file.

        If the 'Mesh' element or the 'Nodes' element with the specified 'name' attribute is not found, an appropriate message is printed.

    Example:
        >>> file_name = "input.feb"
        >>> node_name = "MyNodes"
        >>> coordinates_list = [(1.0, 2.0, 3.0), (4.0, 5.0, 6.0), (7.0, 8.0, 9.0)]
        >>> replace_node_in_feb_file(file_name, node_name, coordinates_list)

    Note:
        - This function assumes that the FEBio file exists and is formatted correctly as an XML file.
        - The 'node_name' should match the 'name' attribute of the 'Nodes' element to be replaced.
        - The 'coordinates_list' should contain coordinate tuples in the order [(x1, y1, z1), (x2, y2, z2), ...].
        - The function modifies the FEBio file in-place and does not create a new file.
    """

    # Read the existing FEBio file
    tree = ET.parse(file_name)
    root = tree.getroot()

    # Find the 'Mesh' element
    mesh_element = root.find('Mesh')

    if mesh_element is not None:
        # Find the index of the 'Nodes' element with the specified 'name' attribute
        index = -1
        for i, nodes_element in enumerate(mesh_element):
            if nodes_element.tag == 'Nodes' and nodes_element.get('name') == node_name:
                index = i
                break

        # If the 'Nodes' element with the specified 'name' attribute is found, remove it
        if index != -1:
            mesh_element.remove(mesh_element[index])

            # Create a new 'Nodes' element and set the 'name' attribute
            new_nodes_element = ET.Element('Nodes')
            new_nodes_element.set('name', node_name)
            new_nodes_element.tail = "\n\t\t"
            new_nodes_element.text = "\n\t\t\t"

            # Iterate through the points in the coordinates_list and add them as 'node' elements
            for i, coordinates in enumerate(coordinates_list):
                node_element = ET.SubElement(new_nodes_element, 'node')
                node_element.set('id', str(i + 1))
                coordinates_text = f"{coordinates[0]}, {coordinates[1]}, {coordinates[2]}"
                node_element.text = coordinates_text
                node_element.tail = "\n\t\t\t"

            new_nodes_element[-1].tail = "\n\t\t"
            mesh_element.insert(index, new_nodes_element)

            # Write the updated XML tree back to the file
            tree.write(file_name, encoding='utf-8', xml_declaration=True)
        else:
            print(f"No 'Nodes' element with the name '{node_name}' found.")
    else:
        print("No 'Mesh' element found.")


def get_dataset_from_feb_file(file_name, node_name):
    """
    Extracts points from an FEB file and returns them as an instance of the DataSet3d class.

    Parameters:
        file_name (str): The name of the FEB file.
        node_name (str): The name of the node element in the FEB file.

    Returns:
        DataSet3d: An instance of DataSet3d containing the extracted points.

    Description:
        This function reads an FEB file specified by 'file_name' and extracts the points belonging to the specified 'node_name'.
        The 'node_name' is used to locate the 'Nodes' element within the FEB file.

        The function utilizes the 'extract_coordinates_list_from_feb' function to extract the coordinates of the nodes.
        The extracted points are then converted to a numpy array and stored in the 'points' variable.

        Finally, the function creates an instance of the DataSet3d class using the extracted x, y, and z coordinates from 'points'
        and returns it as the result.

    Example usage:
        >>> dataset = get_dataset_from_feb_file('input.feb', 'MyNodes')
    """
    points = np.array(extract_coordinates_list_from_feb(file_name, node_name))

    return DataSet3d(list(points[:, 0]), list(points[:, 1]), list(points[:, 2]))


# TODO: CHECK the return and add Val
def get_interconnections_feb(file_name, node_name):  # connections-between-material
    """
    Extracts the interconnections between nodes in a specified 'Nodes' element from an FEB file.

    Parameters:
        file_name (str): The name of the FEB file.
        node_name (str): The name of the 'Nodes' element from which interconnections should be extracted.

    Returns:
        list: A list of lists, where each sublist contains the node numbers connected to the corresponding node.

    Description:
        This function reads the FEB file specified by 'file_name' and searches for the 'Nodes' element with the specified 'node_name'.
        It extracts the interconnections between the nodes by parsing the subsequent 'Elements' element and its 'elem' elements.
        The extracted interconnections are returned as a list of lists, where each sublist contains the node numbers connected to the corresponding node.

        If the 'Nodes' element with the specified 'node_name' is not found, an empty list is returned.

    Example:
        >>> file_name = "input.feb"
        >>> node_name = "MyNodes"
        >>> connections = get_interconnections_feb(file_name, node_name)
        >>> print(connections)
        [[2, 3, 4], [1, 4], [1, 2, 4], [1, 2, 3]]

    Note:
        - This function assumes that the FEB file exists and is formatted correctly as an XML file.
        - The 'node_name' should match the 'name' attribute of the target 'Nodes' element.
        - The interconnections are based on the 'Elements' element and its 'elem' elements in the XML tree structure.
        - The function does not validate the connectivity or perform any checks on the interconnections.
    """

    connections = []
    number_of_nodes = len(extract_coordinates_list_from_feb(file_name, node_name))

    # creates a list of empty nodes
    for i in range(0, number_of_nodes):
        connections.append([])

    tree = ET.parse(file_name)
    root = tree.getroot()

    # Convert the XML tree into a list
    xml_elements = list(root.iter())

    # Find the 'Nodes' element with the target_name attribute
    for i, element in enumerate(xml_elements):
        if element.tag == "Nodes" and element.attrib.get('name') == node_name:
            for next_element in xml_elements[i + 1:]:
                if next_element.tag == "Elements":
                    for elem in next_element.iter('elem'):
                        temp_list = list(map(int, elem.text.split(',')))
                        connections = addToVals(connections, temp_list[1:])
                    break
            break

    return connections
